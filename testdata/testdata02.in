Mnemonic;Opcode;OpcodeVal;OpcodeMask;Syntax;Operands;Description;Bytes
ADC;0001 11rd dddd rrrr;0001110000000000;1111110000000000;ADC Rd,Rr;0<=d<=31, 0<=r<=31;Add with Carry;2
ADD;0000 11rd dddd rrrr;0000110000000000;1111110000000000;ADD Rd,Rr;0<=d<=31, 0<=r<=31;Add without Carry;2
ADIW;1001 0110 KKdd KKKK;1001011000000000;1111111100000000;ADIW Rd+1:Rd,K;d{24,26,28,30}, 0<=K<=63;Add Immediate to Word;2
AND;0010 00rd dddd rrrr;0010000000000000;1111110000000000;AND Rd,Rr;0<=d<=31, 0<=r<=31;Logical AND;2
ANDI;0111 KKKK dddd KKKK;0111000000000000;1111000000000000;ANDI Rd,K;16<=d<=31, 0<=K<=255;Logical AND with Immediate;2
ASR;1001 010d dddd 0101;1001010000000101;1111111000001111;ASR Rd;0<=d<=31;Arithmetic Shift Right;2
BCLR;1001 0100 1sss 1000;1001010010001000;1111111110001111;BCLR s;0<=s<=7;Bit Clear in SREG;2
BLD;1111 100d dddd 0bbb;1111100000000000;1111111000001000;BLD Rd,b;0<=d<=31, 0<=b<=7;Bit Load from the T Flag in SREG to a Bit in Register;2
BRBC;1111 01kk kkkk ksss;1111010000000000;1111110000000000;BRBC s,k;0<=s<=7, -64<=k<=+63;Branch if Bit in SREG is Cleared;2
BRBS;1111 00kk kkkk ksss;1111000000000000;1111110000000000;BRBS s,k;0<=s<=7, -64<=k<=+63;Branch if Bit in SREG is Set;2
BRCC;1111 01kk kkkk k000;1111010000000000;1111110000000111;BRCC k;-64<=k<=+63;Branch if Carry Cleared;2
BRCS;1111 00kk kkkk k000;1111000000000000;1111110000000111;BRCS k;-64<=k<=+63;Branch if Carry Set;2
BREAK;1001 0101 1001 1000;1001010110011000;1111111111111111;BREAK;None;Break;2
BREQ;1111 00kk kkkk k001;1111000000000001;1111110000000111;BREQ k;-64<=k<=+63;Branch if Equal;2
BRGE;1111 01kk kkkk k100;1111010000000100;1111110000000111;BRGE k;-64<=k<=+63;Branch if Greater or Equal (Signed);2
BRHC;1111 01kk kkkk k101;1111010000000101;1111110000000111;BRHC k;-64<=k<=+63;Branch if Half Carry Flag is Cleared;2
BRHS;1111 00kk kkkk k101;1111000000000101;1111110000000111;BRHS k;-64<=k<=+63;Branch if Half Carry Flag is Set;2
BRID;1111 01kk kkkk k111;1111010000000111;1111110000000111;BRID k;-64<=k<=+63;Branch if Global Interrupt is Disabled;2
BRIE;1111 00kk kkkk k111;1111000000000111;1111110000000111;BRIE k;-64<=k<=+63;Branch if Global Interrupt is Enabled;2
BRLO;1111 00kk kkkk k000;1111000000000000;1111110000000111;BRLO k;-64<=k<=+63;Branch if Lower (Unsigned);2
BRLT;1111 00kk kkkk k100;1111000000000100;1111110000000111;BRLT k;-64<=k<=+63;Branch if Less Than (Signed);2
BRMI;1111 00kk kkkk k010;1111000000000010;1111110000000111;BRMI k;-64<=k<=+63;Branch if Minus;2
BRNE;1111 01kk kkkk k001;1111010000000001;1111110000000111;BRNE k;-64<=k<=+63;Branch if Not Equal;2
BRPL;1111 01kk kkkk k010;1111010000000010;1111110000000111;BRPL k;-64<=k<=+63;Branch if Plus;2
BRSH;1111 01kk kkkk k000;1111010000000000;1111110000000111;BRSH k;-64<=k<=+63;Branch if Same or Higher (Unsigned);2
BRTC;1111 01kk kkkk k110;1111010000000110;1111110000000111;BRTC k;-64<=k<=+63;Branch if the T Flag is Cleared;2
BRTS;1111 00kk kkkk k110;1111000000000110;1111110000000111;BRTS k;-64<=k<=+63;Branch if the T Flag is Set;2
BRVC;1111 01kk kkkk k011;1111010000000011;1111110000000111;BRVC k;-64<=k<=+63;Branch if Overflow Cleared;2
BRVS;1111 00kk kkkk k011;1111000000000011;1111110000000111;BRVS k;-64<=k<=+63;Branch if Overflow Set;2
BSET;1001 0100 0sss 1000;1001010000001000;1111111110001111;BSET s;0<=s<=7;Bit Set in SREG;2
BST;1111 101d dddd 0bbb;1111101000000000;1111111000001000;BST Rd,b;0<=d<=31, 0<=b<=7;Bit Store from Bit in Register to T Flag in SREG;2
CALL;1001 010k kkkk 111k;1001010000001110;1111111000001110;CALL k;0<=k < 64K;Long Call to a Subroutine;4
CBI;1001 1000 AAAA Abbb;1001100000000000;1111111100000000;CBI A,b;0<=A<=31, 0<=b<=7;Clear Bit in I/O Register;2
CBR;0111 KKKK dddd KKKK;0111000000000000;1111000000000000;CBR Rd,K;16<=d<=31, 0<=K<=255;Clear Bits in Register;2
CLC;1001 0100 1000 1000;1001010010001000;1111111111111111;CLC;None;Clear Carry Flag;2
CLH;1001 0100 1101 1000;1001010011011000;1111111111111111;CLH;None;Clear Half Carry Flag;2
CLI;1001 0100 1111 1000;1001010011111000;1111111111111111;CLI;None;Clear Global Interrupt Flag;2
CLR;0010 01dd dddd dddd;0010010000000000;1111110000000000;CLR Rd;0<=d<=31;Clear Register;2
CLN;1001 0100 1010 1000;1001010010101000;1111111111111111;CLN;None;Clear Negative Flag;2
CLS;1001 0100 1100 1000;1001010011001000;1111111111111111;CLS;None;Clear Signed Flag;2
CLT;1001 0100 1110 1000;1001010011101000;1111111111111111;CLT;None;Clear T Flag;2
CLV;1001 0100 1011 1000;1001010010111000;1111111111111111;CLV;None;Clear Overflow Flag;2
CLZ;1001 0100 1001 1000;1001010010011000;1111111111111111;CLZ;None;Clear Zero Flag;2
COM;1001 010d dddd 0000;1001010000000000;1111111000001111;COM Rd;0<=d<=31;Ones Complement;2
CP;0001 01rd dddd rrrr;0001010000000000;1111110000000000;CP Rd,Rr;0<=d<=31, 0<=r<=31;Compare;2
CPC;0000 01rd dddd rrrr;0000010000000000;1111110000000000;CPC Rd,Rr;0<=d<=31, 0<=r<=31;Compare with Carry;2
CPI;0011 KKKK dddd KKKK;0011000000000000;1111000000000000;CPI Rd,K;16<=d<=31, 0<=K<=255;Compare with Immediate;2
CPSE;0001 00rd dddd rrrr;0001000000000000;1111110000000000;CPSE Rd,Rr;0<=d<=31, 0<=r<=31;Compare Skip if Equal;2
DEC;1001 010d dddd 1010;1001010000001010;1111111000001111;DEC Rd;0<=d<=31;Decrement;2
DES;1001 0100 KKKK 1011;1001010000001011;1111111100001111;DES K;0x00<=K<=0x0F;Data Encryption Standard;2
EICALL;1001 0101 0001 1001;1001010100011001;1111111111111111;EICALL;None;Extended Indirect Call to Subroutine;2
EIJMP;1001 0100 0001 1001;1001010000011001;1111111111111111;EIJMP;None;Extended Indirect Jump;2
ELPM;1001 0101 1101 1000;1001010111011000;1111111111111111;ELPM;None, R0 implied;Extended Load Program Memory;2
ELPM;1001 000d dddd 0110;1001000000000110;1111111000001111;ELPM Rd, Z;0<=d<=31;Extended Load Program Memory;2
ELPM;1001 000d dddd 0111;1001000000000111;1111111000001111;ELPM Rd, Z+;0<=d<=31;Extended Load Program Memory;2
EOR;0010 01rd dddd rrrr;0010010000000000;1111110000000000;EOR Rd,Rr;0<=d<=31, 0<=r<=31;Exclusive OR;2
FMUL;0000 0011 0ddd 1rrr;0000001100001000;1111111110001000;FMUL Rd,Rr;16<=d<=23, 16<=r<=23;Fractional Multiply Unsigned;2
FMULS;0000 0011 1ddd 0rrr;0000001110000000;1111111110001000;FMULS Rd,Rr;16<=d<=23, 16<=r<=23;Fractional Multiply Signed;2
FMULSU;0000 0011 1ddd 1rrr;0000001110001000;1111111110001000;FMULSU Rd,Rr ;16<=d<=23, 16<=r<=23;Fractional Multiply Signed with Unsigned;2
ICALL;1001 0101 0000 1001;1001010100001001;1111111111111111;ICALL;None;Indirect Call to Subroutine;2
IJMP;1001 0100 0000 1001;1001010000001001;1111111111111111;IJMP;None;Indirect Jump;2
IN;1011 0AAd dddd AAAA;1011000000000000;1111100000000000;IN Rd,A;0<=d<=31, 0<=A<=63;Load an I/O Location to Register;2
INC;1001 010d dddd 0011;1001010000000011;1111111000001111;INC Rd;0<=d<=31;Increment;2
JMP;1001 010k kkkk 110k;1001010000001100;1111111000001110;JMP k;0<=k < 4M;Jump;4
LAC;1001 001r rrrr 0110;1001001000000110;1111111000001111;LAC Z,Rd;0<=d<=31;Load and Clear;2
LAS;1001 001r rrrr 0101;1001001000000101;1111111000001111;LAS Z,Rd;0<=d<=31;Load and Set;2
LAT;1001 001r rrrr 0111;1001001000000111;1111111000001111;LAT Z,Rd;0<=d<=31;Load and Toggle;2
LD;1001 000d dddd 1100;1001000000001100;1111111000001111;LD Rd, X;0<=d<=31;Load Indirect from Data Space to Register using Index X;2
LD;1001 000d dddd 1101;1001000000001101;1111111000001111;LD Rd, X+;0<=d<=31;Load Indirect from Data Space to Register using Index X;2
LD;1001 000d dddd 1110;1001000000001110;1111111000001111;LD Rd, -X;0<=d<=31;Load Indirect from Data Space to Register using Index X;2
LD;1000 000d dddd 1000;1000000000001000;1111111000001111;LD Rd, Y;0<=d<=31;Load Indirect from Data Space to Register using Index Y;2
LD;1001 000d dddd 1001;1001000000001001;1111111000001111;LD Rd, Y+;0<=d<=31;Load Indirect from Data Space to Register using Index Y;2
LD;1001 000d dddd 1010;1001000000001010;1111111000001111;LD Rd, -Y;0<=d<=31;Load Indirect from Data Space to Register using Index Y;2
LDD;10q0 qq0d dddd 1qqq;1000000000001000;1101001000001000;LDD Rd, Y+q;0<=d<=31, 0<=q<=63;Load Indirect from Data Space to Register using Index Y;2
LD;1000 000d dddd 0000;1000000000000000;1111111000001111;LD Rd, Z;0<=d<=31;Load Indirect From Data Space to Register using Index Z;2
LD;1001 000d dddd 0001;1001000000000001;1111111000001111;LD Rd, Z+;0<=d<=31;Load Indirect From Data Space to Register using Index Z;2
LD;1001 000d dddd 0010;1001000000000010;1111111000001111;LD Rd, -Z;0<=d<=31;Load Indirect From Data Space to Register using Index Z;2
LDD;10q0 qq0d dddd 0qqq;1000000000000000;1101001000001000;LDD Rd, Z+q;0<=r<=31, 0<=q<=63;Load Indirect From Data Space to Register using Index Z;2
LDI;1110 KKKK dddd KKKK;1110000000000000;1111000000000000;LDI Rd,K;16<=d<=31, 0<=K<=255;Load Immediate;2
LDS;1001 000d dddd 0000;1001000000000000;1111111000001111;LDS Rd,k;0<=d<=31, 0<=k<=65535;Load Direct from Data Space;4
LDS;1010 0kkk dddd kkkk;1010000000000000;1111100000000000;LDS Rd,k;16<=d<=31, 0<=k<=127;16 bit Load Direct from Data Space;2
LPM;1001 0101 1100 1000;1001010111001000;1111111111111111;LPM;None, R0 implied;Load Program Memory;2
LPM;1001 000d dddd 0100;1001000000000100;1111111000001111;LPM Rd, Z;0<=d<=31;Load Program Memory;2
LPM;1001 000d dddd 0101;1001000000000101;1111111000001111;LPM Rd, Z+;0<=d<=31;Load Program Memory;2
LSL;0000 11dd dddd dddd;0000110000000000;1111110000000000;LSL Rd;0<=d<=31;Logical Shift Left;2
LSR;1001 010d dddd 0110;1001010000000110;1111111000001111;LSR Rd;0<=d<=31;Logical Shift Right;2
MOV;0010 11rd dddd rrrr;0010110000000000;1111110000000000;MOV Rd,Rr;0<=d<=31, 0<=r<=31;Copy Register;2
MOVW;0000 0001 dddd rrrr;0000000100000000;1111111100000000;MOVW Rd+1:Rd,Rr+1:Rr;d{0,2,...,30}, r{0,2,...,30};Copy Register Word;2
MUL;1001 11rd dddd rrrr;1001110000000000;1111110000000000;MUL Rd,Rr;0<=d<=31, 0<=r<=31;Multiply Unsigned;2
MULS;0000 0010 dddd rrrr;0000001000000000;1111111100000000;MULS Rd,Rr;16<=d<=31, 16<=r<=31;Multiply Signed;2
MULSU;0000 0011 0ddd 0rrr;0000001100000000;1111111110001000;MULSU Rd,Rr;16<=d<=23, 16<=r<=23;Multiply Signed with Unsigned;2
NEG;1001 010d dddd 0001;1001010000000001;1111111000001111;NEG Rd;0<=d<=31;Twos Complement;2
NOP;0000 0000 0000 0000;0000000000000000;1111111111111111;NOP;None;No Operation;2
OR;0010 10rd dddd rrrr;0010100000000000;1111110000000000;OR Rd,Rr;0<=d<=31, 0<=r<=31;Logical OR;2
ORI;0110 KKKK dddd KKKK;0110000000000000;1111000000000000;ORI Rd,K;16<=d<=31, 0<=K<=255;Logical OR with Immediate;2
OUT;1011 1AAr rrrr AAAA;1011100000000000;1111100000000000;OUT A,Rr;0<=r<=31, 0<=A<=63;Store Register to I/O Location;2
POP;1001 000d dddd 1111;1001000000001111;1111111000001111;POP Rd;0<=d<=31;Pop Register from Stack;2
PUSH;1001 001d dddd 1111;1001001000001111;1111111000001111;PUSH Rr;0<=r<=31;Push Register on Stack;2
RCALL;1101 kkkk kkkk kkkk;1101000000000000;1111000000000000;RCALL k;-2K<=k < 2K;Relative Call to Subroutine;2
RET;1001 0101 0000 1000;1001010100001000;1111111111111111;RET;None;Return from Subroutine;2
RETI;1001 0101 0001 1000;1001010100011000;1111111111111111;RETI;None;Return from Interrupt;2
RJMP;1100 kkkk kkkk kkkk;1100000000000000;1111000000000000;RJMP k;k -2K<=k < 2K;Relative Jump;2
ROL;0001 11dd dddd dddd;0001110000000000;1111110000000000;ROL Rd;0<=d<=31;Rotate Left trough Carry;2
ROR;1001 010d dddd 0111;1001010000000111;1111111000001111;ROR Rd;0<=d<=31;Rotate Right through Carry;2
SBC;0000 10rd dddd rrrr;0000100000000000;1111110000000000;SBC Rd,Rr;0<=d<=31, 0<=r<=31;Subtract with Carry;2
SBCI;0100 KKKK dddd KKKK;0100000000000000;1111000000000000;SBCI Rd,K;16<=d<=31, 0<=K<=255;Subtract Immediate with Carry SBI Set Bit in I/O Register;2
SBI;1001 1010 AAAA Abbb;1001101000000000;1111111100000000;SBI A,b;0<=A<=31, 0<=b<=7;Set Bit in I/O Register;2
SBIC;1001 1001 AAAA Abbb;1001100100000000;1111111100000000;SBIC A,b;0<=A<=31, 0<=b<=7;Skip if Bit in I/O Register is Cleared;2
SBIS;1001 1011 AAAA Abbb;1001101100000000;1111111100000000;SBIS A,b;0<=A<=31, 0<=b<=7;Skip if Bit in I/O Register is Set;2
SBIW;1001 0111 KKdd KKKK;1001011100000000;1111111100000000;SBIW Rd+1:Rd,K;d{24,26,28,30}, 0<=K<=63;Subtract Immediate from Word;2
SBR;0110 KKKK dddd KKKK;0110000000000000;1111000000000000;SBR Rd,K;16<=d<=31, 0<=K<=255;Set Bits in Register;2
SBRC;1111 110r rrrr 0bbb;1111110000000000;1111111000001000;SBRC Rr,b;0<=r<=31, 0<=b<=7;Skip if Bit in Register is Cleared;2
SBRS;1111 111r rrrr 0bbb;1111111000000000;1111111000001000;SBRS Rr,b;0<=r<=31, 0<=b<=7;Skip if Bit in Register is Set;2
SEC;1001 0100 0000 1000;1001010000001000;1111111111111111;SEC;None;Set Carry Flag;2
SEH;1001 0100 0101 1000;1001010001011000;1111111111111111;SEH;None;Set Half Carry Flag;2
SEI;1001 0100 0111 1000;1001010001111000;1111111111111111;SEI;None;Set Global Interrupt Flag;2
SEN;1001 0100 0010 1000;1001010000101000;1111111111111111;SEN;None;Set Negative Flag;2
SER;1110 1111 dddd 1111;1110111100001111;1111111100001111;SER Rd;16<=d<=31;Set all Bits in Register;2
SES;1001 0100 0100 1000;1001010001001000;1111111111111111;SES;None;Set Signed Flag;2
SET;1001 0100 0110 1000;1001010001101000;1111111111111111;SET;None;Set T Flag;2
SEV;1001 0100 0011 1000;1001010000111000;1111111111111111;SEV;None;Set Overflow Flag;2
SEZ;1001 0100 0001 1000;1001010000011000;1111111111111111;SEZ;None;Set Zero Flag;2
SLEEP;1001 0101 1000 1000;1001010110001000;1111111111111111;SLEEP;None;Sleep;2
SPM;1001 0101 1110 1000;1001010111101000;1111111111111111;SPM;Z+;Store Program Memory;2
ST;1001 001r rrrr 1100;1001001000001100;1111111000001111;ST X, Rr;0<=r<=31;Store Indirect From Register to Data Space using Index X;2
ST;1001 001r rrrr 1101;1001001000001101;1111111000001111;ST X+, Rr;0<=r<=31;Store Indirect From Register to Data Space using Index X;2
ST;1001 001r rrrr 1110;1001001000001110;1111111000001111;ST -X, Rr;0<=r<=31;Store Indirect From Register to Data Space using Index X;2
ST;1000 001r rrrr 1000;1000001000001000;1111111000001111;ST Y, Rr;0<=r<=31;Store Indirect From Register to Data Space using Index Y;2
ST;1001 001r rrrr 1001;1001001000001001;1111111000001111;ST Y+, Rr;0<=r<=31;Store Indirect From Register to Data Space using Index Y;2
ST;1001 001r rrrr 1010;1001001000001010;1111111000001111;ST -Y, Rr;0<=r<=31;Store Indirect From Register to Data Space using Index Y;2
STD;10q0 qq1r rrrr 1qqq;1000001000001000;1101001000001000;STD Y+q, Rr;0<=r<=31, 0<=q<=63;Store Indirect From Register to Data Space using Index Y;2
ST;1000 001r rrrr 0000;1000001000000000;1111111000001111;ST Z, Rr;0<=r<=31;Store Indirect From Register to Data Space using Index Z;2
ST;1001 001r rrrr 0001;1001001000000001;1111111000001111;ST Z+, Rr;0<=r<=31;Store Indirect From Register to Data Space using Index Z;2
ST;1001 001r rrrr 0010;1001001000000010;1111111000001111;ST -Z, Rr ;0<=r<=31;Store Indirect From Register to Data Space using Index Z;2
STD;10q0 qq1r rrrr 0qqq;1000001000000000;1101001000001000;STD Z+q, Rr;0<=r<=31, 0<=q<=63;Store Indirect From Register to Data Space using Index Z;2
STS;1001 001d dddd 0000;1001001000000000;1111111000001111;STS k,Rr;0<=r<=31, 0<=k<=65535;Store Direct to Data Space;4
STS;1010 1kkk dddd kkkk;1010100000000000;1111100000000000;STS k,Rr;16<=r<=31, 0<=k<=127;16 bit Store Direct to Data Space;2
SUB;0001 10rd dddd rrrr;0001100000000000;1111110000000000;SUB Rd,Rr;0<=d<=31, 0<=r<=31;Subtract Without Carry;2
SUBI;0101 KKKK dddd KKKK;0101000000000000;1111000000000000;SUBI Rd,K;16<=d<=31, 0<=K<=255;Subtract Immediate;2
SWAP;1001 010d dddd 0010;1001010000000010;1111111000001111;SWAP Rd;0<=d<=31;Swap Nibbles;2
TST;0010 00dd dddd dddd;0010000000000000;1111110000000000;TST Rd;0<=d<=31;Test for Zero or Minus;2
WDR;1001 0101 1010 1000;1001010110101000;1111111111111111;WDR;None;Watchdog Reset;2
XCH;1001 001r rrrr 0100;1001001000000100;1111111000001111;XCH Z,Rd;0<=d<=31;Exchange;2
???;zzzz zzzz zzzz zzzz;1010101010101010;1010101010101010;UNKNOWN;UNKNOWN;UNKNOWN;2
